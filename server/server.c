#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

//------
struct message
{
    char privfifo[15]; // имя частного именованного канала
    char data[100]; // информация, которая будет передана
};

#define PUBLIC "public" // имя общедоступного именованного программного канала
#define LINESIZE 512
//------

int main(int argc, char *argv[])
{
    int fdpub, fdpriv;
    struct message msg;// структура сообщения, которое читается из общедоступного именованного канала
    char line[LINESIZE];

loop: // бесконечный цикл

    /*
     * Общедоступный канал открывается для чтения.
     * Системный вызов open() блокируется, если
     * никакой процесс-клиент не открывает другой конец канала
     */
    if ((fdpub = open(PUBLIC, O_RDONLY)) == -1)
    {
        // если вдруг ошибка
        perror(PUBLIC);
        exit(1);
    }

    /*
     * Из общедоступного канала читается сообщение, содержащее имена личного канала и
     * строку, которую надо отформатировать и форматируем её
     */
    while(read(fdpub, (char*)&msg, sizeof(msg)) > 0)
    {
        if ((fdpriv = open(msg.privfifo, O_WRONLY)) == -1)
        {
            perror(msg.privfifo);
            break;
        }

        //---------------------------------------
        //----------форматируем строку-----------
        //-----------использую фильтр2-----------
        int i, j = 0;
        for (i = 0; i < strlen(msg.data); i++)
        {
            if (msg.data[i] <= '0' || msg.data[i] >= '9')
                line[j++] = msg.data[i];
        }
        line[j] = '\0';
        //---------------------------------------
        //---------------------------------------
        //---------------------------------------

        // пишем данные в личный именованный канал
        write(fdpriv, line, strlen(line));

        // закрываем личный именованный канал
        close(fdpriv);
    }

    /*
     * закрываем общедоступный канал - Сервер переходит к следующему витку цикла.
     * Причина для закрытия и повторного открытия состоит в том, что хочется,
     * чтобы файловый сервер спал на open(), ожидая запросов.
     */
    close(fdpub);
    goto loop;
    /* !Программа никогда не завершается */
}
